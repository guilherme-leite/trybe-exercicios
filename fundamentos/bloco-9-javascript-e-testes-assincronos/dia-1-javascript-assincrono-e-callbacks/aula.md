OperaÃ§Ãµes assÃ­ncronas
OperaÃ§Ãµes em JavaScript sÃ£o tradicionalmente sÃ­ncronas, ou seja, para que uma cadeia de operaÃ§Ãµes seja realizada, Ã© necessÃ¡rio que uma operaÃ§Ã£o termine para que outra comece. Em uma linha de produÃ§Ã£o de automÃ³veis por exemplo, vÃ¡rias etapas de produÃ§Ã£o sÃ£o codependentes. Podemos relacionar estas etapas de produÃ§Ã£o Ã s operaÃ§Ãµes sÃ­ncronas em JavaScript. Observe o exemplo abaixo para que esta analogia fique mais nÃ­tida:
Copiar
console.log('1 - Receber roda');
console.log('2 - Encaixar parafusos');
console.log('3 - Fixar roda no carro');
Note que existe uma ordem especÃ­fica de etapas que nÃ£o pode ser quebrada pois uma afeta diretamente a outra. Sem roda, nÃ£o adianta encaixar parafusos, sem encaixar parafusos, fixar a roda nÃ£o Ã© possÃ­vel.
Agora imagine que o nosso estoque de parafusos estÃ¡ chegando ao fim e Ã© necessÃ¡rio que faÃ§amos uma reposiÃ§Ã£o para que a linha de produÃ§Ã£o nÃ£o pare. No entanto, nossa operaÃ§Ã£o nÃ£o cobre este tipo situaÃ§Ã£o e nossa linha de produÃ§Ã£o para enquanto uma pessoa funcionÃ¡ria irÃ¡ comprar os parafusos e repor o estoque.
Copiar
console.log('1 - Comprar parafusos');
console.log('2 - Adicionar ao estoque');
console.log('3 - Receber roda');
console.log('4 - Encaixar parafusos');
console.log('5 - Fixar roda no carro');
Observe que estamos trabalhando de forma ineficiente e adicionando etapas desnecessÃ¡rias Ã  nossa produÃ§Ã£o pois se tivermos parafusos suficientes em estoque, nÃ£o precisamos parar a montagem para que mais parafusos sejam comprados e repostos. Assim como na nossa linha de produÃ§Ã£o, existem operaÃ§Ãµes que nÃ£o possuem esta codependÃªncia em JavaScript, e com objetivo de cobrir justamente este tipo de situaÃ§Ã£o surgem as operaÃ§Ãµes assÃ­ncronas .
Rode em seu editor o cÃ³digo abaixo e veja como nossa linha de produÃ§Ã£o jÃ¡ nÃ£o depende mais das etapas de compra de parafusos e de reposiÃ§Ã£o do estoque.
NÃ£o se preocupe com o cÃ³digo em si, falaremos da funÃ§Ã£o setTimeout logo mais! ğŸ˜‰
Copiar
setTimeout(() => {
  console.log('Comprar parafusos') // Comprar parafusos
  console.log('Adicionar ao estoque') // Adicionar ao estoque
}, 2000);

console.log('1 - Receber roda'); // 1 - Receber roda
console.log('2 - Encaixar parafusos'); // 2 - Encaixar parafusos
console.log('3 - Fixar roda no carro'); // 3 - Fixar roda no carro
Note que console.log('Comprar parafusos') e console.log('Adicionar ao estoque') foram declarados antes das etapas 1 , 2 e 3 , mesmo assim o retorno das chamadas sÃ³ ocorre ao final. Isto acontece pois utilizamos a funÃ§Ã£o setTimeout . Ã‰ muito comum que esta funÃ§Ã£o seja utilizada para simular comportamentos assÃ­ncronos. Na prÃ¡tica vivenciaremos situaÃ§Ãµes em que nossa aplicaÃ§Ã£o depende de uma informaÃ§Ã£o externa, como por exemplo, solicitar uma informaÃ§Ã£o a um banco de dados. Ã‰ aÃ­ que o conceito de assincronicidade entra a nosso favor para que nossa aplicaÃ§Ã£o nÃ£o perca eficiÃªncia.
Agora, vamos ver um pouco da prÃ¡tica realizando este exercÃ­cio de fixaÃ§Ã£o. Copie o cÃ³digo para ser executado na sua mÃ¡quina:
Copiar
const pushNumber = (list, number) => list.push(number);

let numbers = [];

pushNumber(numbers, 1);
pushNumber(numbers, 2);
pushNumber(numbers, 3);

console.log(numbers);
Copiar
const pushNumber = (list, number) => list.push(number);

let numbers = [];

setTimeout(() => pushNumber(numbers, 1), 3000);
pushNumber(numbers, 2);
pushNumber(numbers, 3);

console.log(numbers); // O retorno Ã© [2, 3]
Por que o primeiro cÃ³digo retorna o array [1, 2, 3] enquanto o segundo retorna o array [2, 3] ? Isso ocorre por causa da funÃ§Ã£o setTimeout . Ela Ã© uma funÃ§Ã£o assÃ­ncrona, que espera alguns milissegundos para executar a funÃ§Ã£o passada a ela como parÃ¢metro. No cÃ³digo acima, ela espera 3000 milissegundos (3 segundos) para executar o pushNumber(numbers, 1) . Como o console.log Ã© uma funÃ§Ã£o sÃ­ncrona, ele Ã© executado antes do setTimeout terminar.
Para que o console.log mostre o array correto, Ã© necessÃ¡rio chamÃ¡-lo apÃ³s 3000 milissegundos:
Copiar
const pushNumber = (list, number) => list.push(number);

let numbers = [];

setTimeout(() => pushNumber(numbers, 1), 3000);
pushNumber(numbers, 2);
pushNumber(numbers, 3);

setTimeout(() => console.log(numbers), 3000);
Observe que, alÃ©m de adicionar o setTimeout , o array [1, 2, 3] foi modificado para [2, 3, 1] . Isso se dÃ¡, pois, como a funÃ§Ã£o Ã© assÃ­ncrona, o cÃ³digo continua rodando, mesmo que ela ainda nÃ£o tenha terminado de executar. Ou seja, o array recebe primeiro o 2 , depois o 3 , e apÃ³s os 3 segundos do setTimeout , ele recebe o 1 .
Para saber mais a respeito de setTimeout , acesse este link.

Callbacks
Agora que o conceito de assincronicidade estÃ¡ mais nÃ­tido, Ã© hora de dar luz a callbacks !
De forma resumida, callback Ã© uma funÃ§Ã£o passada como parÃ¢metro para outra funÃ§Ã£o . Sem perceber, vocÃª viu um exemplo de funÃ§Ã£o callback quando chamamos a funÃ§Ã£o setTimeout . Esta funÃ§Ã£o recebe dois parÃ¢metros, o primeiro Ã© a funÃ§Ã£o callback que passamos atravÃ©s de uma arrow function , e o segundo Ã© o tempo (em milissegundos) que o interpretador irÃ¡ esperar para executar a funÃ§Ã£o. Observe a estrutura dela:
setTimeout(1parametro, 2parametro);
O primeiro parÃ¢metro Ã© uma callback sem nome: () => {} . O segundo parÃ¢metro serÃ¡ o tempo de espera: 2000 (2000 milissegundos ou 2 segundos, por exemplo).
setTimeout(() => {}, 2000);
Agora veremos um exemplo prÃ¡tico de como podemos utilizar funÃ§Ãµes callback . Copie e analise com calma cada trecho da implementaÃ§Ã£o do cÃ³digo, se necessÃ¡rio, volte na explicaÃ§Ã£o para que a implementaÃ§Ã£o seja bem compreendida!
Este exemplo estÃ¡ em portuguÃªs para facilitar a compreensÃ£o, os prÃ³ximos estarÃ£o em inglÃªs, ok?
Copiar
const despesas = [
  {
    gym: 99,
  },
  {
    ifood: 200,
  },
  {
    phone: 60,
  },
  {
    internet: 100,
  },
];

const renda = 1000;
Neste primeiro trecho de cÃ³digo temos duas declaraÃ§Ãµes de variÃ¡veis. A primeira delas, despesas , Ã© um array de objetos que representa os gastos de uma pessoa no mÃªs. A segunda, renda , representa o quanto esta pessoa recebeu neste mesmo mÃªs.
Nosso prÃ³ximo passo serÃ¡ implementar uma funÃ§Ã£o que trate estas informaÃ§Ãµes para que tenhamos como resultado um balanÃ§o de entradas e saÃ­das do mÃªs.
Copiar
const despesaMensal = (renda, despesas, callback) => {

  const despesaTotal = callback(despesas);
  const saldoFinal = renda - despesaTotal;

  console.log(`BalanÃ§o do mÃªs:
    Recebido: R$${renda},00
    Gasto: R$${despesaTotal},00
    Saldo: R$${saldoFinal},00 `);
};
Neste trecho da implementaÃ§Ã£o, podemos notar que foi adicionada a funÃ§Ã£o despesaMensal , que recebe trÃªs parÃ¢metros: renda , despesas , e callback . Acredito que vocÃª deva estar pensando: "O que este parÃ¢metro callback estÃ¡ fazendo nesta funÃ§Ã£o?".
Como vimos anteriormente, callback Ã©, basicamente, uma funÃ§Ã£o passada por parÃ¢metro para outra funÃ§Ã£o. Neste exemplo, o parÃ¢metro callback receberÃ¡ uma funÃ§Ã£o que retornarÃ¡ o quanto gastamos no mÃªs, ou seja, nossa funÃ§Ã£o callback irÃ¡ realizar a lÃ³gica necessÃ¡ria para somar todos os gastos contidos no array de objetos despesas e retornarÃ¡ este valor para a constante despesaTotal .
Copiar
const somaDespesas = (despesas) => {
  const custoItem = despesas.map((item) => Object.values(item));
  const despesaTotal = custoItem.reduce((acc, curr) => acc += curr[0], 0);
  return despesaTotal;
};

// acc Ã© a sigla para accumulator (acumulador)
// curr Ã© a sigla para current (valor atual)

despesaMensal(renda, despesas, somaDespesas);
Por fim, podemos observar a implementaÃ§Ã£o da funÃ§Ã£o callback , representada pela funÃ§Ã£o somaDespesas . Essa funÃ§Ã£o estÃ¡ tratando as informaÃ§Ãµes contidas no array de objetos despesas e retornando o valor total de gastos.
Em sÃ­ntese o que fizemos foi:
1 - Criamos variÃ¡veis que representam o quanto recebemos no mÃªs e o quanto gastamos no mÃªs.
2 - Implementamos a funÃ§Ã£o despesaMensal que recebe trÃªs parÃ¢metros: nossas despesas, nossa renda e a funÃ§Ã£o callback .
3 - Realizamos a implementaÃ§Ã£o da funÃ§Ã£o callback representada por somaDespesas que recebe nossos gastos mensais e retorna um valor de gastos total.
4 - Adicionamos somaDespesas na chamada da funÃ§Ã£o despesaMensal e como resultado temos o balanÃ§o mensal.
Copiar
// Declaramos nossa variÃ¡vel de despesas
const despesas = [
  {
    gym: 99,
  },
  {
    ifood: 200,
  },
  {
    phone: 60,
  },
  {
    internet: 100,
  },
];

// Declaramos nossa renda
const renda = 1000;

const despesaMensal = (renda, despesas, callback) => {
  // Definimos que a despesa total Ã© igual ao valor retornado pela funÃ§Ã£o callback (que Ã© o parÃ¢metro da nossa funÃ§Ã£o)
  // que vai receber nosso parÃ¢metro/variÃ¡vel "despesas"
  const despesaTotal = callback(despesas);
  // Definimos nosso saldo final, que Ã© nossa renda - nossa despesa total
  const saldoFinal = renda - despesaTotal;

  console.log(`BalanÃ§o do mÃªs:
    Recebido: R$${renda},00
    Gasto: R$${despesaTotal},00
    Saldo: R$${saldoFinal},00 `);
};

// Definimos nossa funÃ§Ã£o que serÃ¡ passada como parÃ¢metro
// essa funÃ§Ã£o recebe o parÃ¢metro despesas a partir da funÃ§Ã£o principal despesaMensal
const somaDespesas = (despesas) => {
  // Separamos cada item do nosso array de despesas
  // e fazemos um reduce para somar os valores
  const custoItem = despesas.map((item) => Object.values(item));
  const despesaTotal = custoItem.reduce((acc, curr) => acc += curr[0], 0);
  return despesaTotal;
};

// Executamos a funÃ§Ã£o principal com as variÃ¡veis renda, despesas
// e a nossa funÃ§Ã£o somaDespesas
// callback = somaDespesas
despesaMensal(renda, despesas, somaDespesas);

// BalanÃ§o do mÃªs:
//     Recebido: R$1000,00
//     Gasto: R$459,00
//     Saldo: R$541,00
Reparou que vocÃª jÃ¡ estava usando callbacks desde a semana de JavaScript , com eventListeners e, atÃ© a semana passada, com filter , map e reduce ? A funÃ§Ã£o que vocÃª passa como parÃ¢metro para cada uma delas Ã© exemplo de funÃ§Ã£o callback . ğŸ˜‰
wink
AlÃ©m disso, lembre-se do exemplo da pizza mencionado no Por que isso Ã© importante ? O que vocÃª faz quando o pedido da pizza chega, que nesse caso Ã© jantar, corresponde a uma callback .
Antes de seguir para os exercÃ­cios de fixaÃ§Ã£o propostos abaixo, veja o vÃ­deo a seguir para garantir o entendimento sobre callbacks :

Para fixar
Lembre-se: quando definimos uma funÃ§Ã£o, o parÃ¢metro pode ter qualquer nome, porÃ©m, ao fazer a execuÃ§Ã£o/chamada dessa funÃ§Ã£o, o parÃ¢metro deve ser um valor definido. No nosso caso, vamos utilizar uma funÃ§Ã£o como parÃ¢metro ( callback ).
Vamos ver um exemplo de como esse processo acontece:
Copiar
// DefiniÃ§Ã£o da funÃ§Ã£o userFullName
const userFullName = ({ firstName, lastName }) => `Hello! My name is ${firstName} ${lastName}`;

// DefiniÃ§Ã£o da funÃ§Ã£o getUser
const getUser = (param) => {
  const userToReturn = {
    firstName: "Ivan",
    lastName: "Ivanovich",
    nationality: "Russian"
  };
  // Retornamos nosso parÃ¢metro, que serÃ¡ uma funÃ§Ã£o (callback)
  return param(userToReturn);
};

// Chamada/execuÃ§Ã£o da funÃ§Ã£o getUser, que vai receber como parÃ¢metro nossa funÃ§Ã£o userFullName.
getUser(userFullName);
Vamos ao passo a passo:
Definimos a funÃ§Ã£o userFullName ;
Definimos a funÃ§Ã£o getUser
Definimos que o parÃ¢metro que a nossa getUser vai receber se chama "param".
Ao executar a funÃ§Ã£o getUser , passamos a funÃ§Ã£o userFullName como parÃ¢metro.
Ou seja, o parÃ¢metro "param" de dentro da nossa getUser Ã© igual Ã  funÃ§Ã£o userFullName . Isso significa que, ao definirmos nossa funÃ§Ã£o, o parÃ¢metro Ã© dinÃ¢mico, ele vai assumir o valor que passarmos no momento em que executarmos a nossa funÃ§Ã£o.
Tenha tranquilidade e lembre-se sempre: Nada melhor do que a prÃ¡tica. E falando nisso... vamos praticar? ;)
Agora, faÃ§a estes exercÃ­cios de fixaÃ§Ã£o:
1 - Adicione uma callback como parÃ¢metro da funcÃ£o getUser .
No cÃ³digo abaixo vocÃª tem a funÃ§Ã£o getUser , que define um objeto com os dados de uma pessoa. Complete a funÃ§Ã£o getUser de forma que ela receba uma funÃ§Ã£o callback como parÃ¢metro para realizar as operaÃ§Ãµes abaixo:
Insira o retorno da funÃ§Ã£o getUser ;
Complete a chamada da funÃ§Ã£o getUser de modo que o retorno seja: "Hello! My name is Ivan Ivanovich";
Complete a chamada da funÃ§Ã£o getUser de modo que o retorno seja: "Ivan is Russian".
Copiar
const userFullName = ({ firstName, lastName }) => `Hello! My name is ${firstName} ${lastName}`;
const userNationality = ({ firstName, nationality }) => `${firstName} is ${nationality}`;

const getUser = () => {
  const userToReturn = {
    firstName: "Ivan",
    lastName: "Ivanovich",
    nationality: "Russian"
  };
  // Insira o retorno da funÃ§Ã£o `getUser`
};

console.log(getUser()); // complete a chamada da funÃ§Ã£o getUser de modo que o retorno seja: "Hello! My name is Ivan Ivanovich"
console.log(getUser()); // complete a chamada da funÃ§Ã£o getUser de modo que o retorno seja: "Ivan is Russian"
2 - Passe, como parÃ¢metro e como retorno, uma callback para a funÃ§Ã£o getUser .
No cÃ³digo abaixo vocÃª tem a funÃ§Ã£o getUser modificada, que agora funciona de modo assÃ­ncrono e imprime dados de uma pessoa depois de um certo tempo. Complete a funÃ§Ã£o getUser de forma que ela receba uma callback como parÃ¢metro e a retorne para que possa realizar as operaÃ§Ãµes abaixo sobre a pessoa:
Insira uma callback como parÃ¢metro da funÃ§Ã£o getUser ;
Retorne a callback passada como parÃ¢metro na funÃ§Ã£o getUser ;
Copiar
const userFullName = ({ firstName, lastName }) => `Hello! My name is ${firstName} ${lastName}`;
const userNationality = ({ firstName, nationality }) => `${firstName} is ${nationality}`;

const delay = (maxMilliseconds = 5000) => Math.floor(Math.random() * maxMilliseconds);

const getUser = () => {
  setTimeout(() => {
    const user = {
      firstName: "Ivan",
      lastName: "Ivanovich",
      nationality: "Russian",
    };
    // Retorne a `callback` passada como parÃ¢metro na funÃ§Ã£o `getUser`
    // Dica: vocÃª pode manter o `console.log()`
    console.log(user);
  }, delay());
};

getUser(userFullName); // deve imprimir "Hello! My name is Ivan Ivanovich" depois de um certo tempo
getUser(userNationality); // deve imprimir "Ivan is Russian" depois de um certo tempo
Obs.: Analise o comportamento assÃ­ncrono da funÃ§Ã£o getUser ao chamar getUser(userFullName) seguido de getUser(userNationality) . Tem hora que o nome da pessoa Ã© impresso antes e tem hora que a nacionalidade da pessoa Ã© impressa antes!

Lidando com erros em operaÃ§Ãµes assÃ­ncronas
No Ãºltimo exercÃ­cio, vocÃª deve ter reparado que estÃ¡ usando em conjunto callbacks e assincronicidade, que nesse caso correspondem a:
operaÃ§Ã£o assÃ­ncrona : retorno de user depois de um certo tempo, que varia;
callbacks : as funÃ§Ãµes userFullName e userNationality , que sÃ£o chamadas depois que o usuÃ¡rio Ã© retornado.
Nesse caso, a operaÃ§Ã£o assÃ­ncrona sempre finaliza com sucesso, e existe uma callback que atua sobre o resultado desse sucesso. Mas isso nÃ£o reflete por completo todas as operaÃ§Ãµes assÃ­ncronas.
Suponha que vocÃª esteja pegando dados de usuÃ¡rio via requisiÃ§Ã£o em um outro servidor. Podemos garantir que essa requisiÃ§Ã£o vai ocorrer sempre com sucesso? E se houver uma falha de conexÃ£o? E se o servidor nÃ£o estiver funcionando no momento da requisiÃ§Ã£o? Esses casos sÃ£o exemplos de fatores externos, sobre os quais nÃ£o se tem controle algum e que precisam ser tratados.
Ou seja, da mesma forma que se tem uma callback para quando a operaÃ§Ã£o assÃ­ncrona tem sucesso, tambÃ©m precisaria ter uma callback para quando a operaÃ§Ã£o assÃ­ncrona termina com erro.
Para fixar
Vamos botar tudo isso em prÃ¡tica com este exercÃ­cio de fixaÃ§Ã£o:
1 - Adicione uma callback e trate o erro retornado.
A funÃ§Ã£o getCountry abaixo tem aproximadamente 50% de chance em obter, com sucesso, um paÃ­s. Ela utiliza uma callback para poder realizar qualquer operaÃ§Ã£o sobre o paÃ­s retornado.
Adicione um segundo parÃ¢metro, que deve ser uma callback , na funÃ§Ã£o getCountry ;
Retorne essa callback na funÃ§Ã£o getCountry de forma que trate a mensagem de erro.
Copiar
const countryName = ({ name }) => console.log(`Returned country is ${name}`);
const countryCurrency = ({ name, currency }) => console.log(`${name}'s currency is the ${currency}`);

const delay = (maxMilliseconds = 5000) => Math.floor(Math.random() * maxMilliseconds);

const printErrorMessage = (error) => console.log(`Error getting country: ${error}`);

const getCountry = (onSuccess) => {
  setTimeout(() => {
    const didOperationSucceed = Math.random() >= 0.5;
    if(didOperationSucceed) {
      const country = {
        name: "Brazil",
        hdi: 0.759,
        currency: "Real",
      };
      onSuccess(country);
    } else {
      const errorMessage = "Country could not be found";
    }
  }, delay());
};

// Deve imprimir "Returned country is Brazil" no sucesso ou "Error getting country: Country could not be found" em caso de falha
getCountry(countryName, printErrorMessage);

// Deve imprimir "Brazil's currency is the Real" no sucesso, ou "Error getting country: Country could not be found" em caso de falha
getCountry(countryCurrency, printErrorMessage);

Testes AssÃ­ncronos com Callbacks
VocÃª viu no exemplo anterior que nem sempre a operaÃ§Ã£o assÃ­ncrona serÃ¡ executada com sucesso. Por esse motivo, Ã© importante manter uma boa cobertura de testes a fim de prevenir possÃ­veis erros. Para isso, vocÃª irÃ¡ utilizar o Jest. Caso nÃ£o se lembre de como instalar e iniciar o Jest, reveja este bloco antes de comeÃ§ar a colocar a mÃ£o na massa.
Ao realizar testes assÃ­ncronos com callbacks, Ã© necessÃ¡rio ter cuidado com falso-positivo (quando o teste deveria falhar mas acaba passando). Isso acontece pois o Jest nÃ£o sabe, por padrÃ£o, quando Ã© necessÃ¡rio esperar o tÃ©rmino da execuÃ§Ã£o de uma funÃ§Ã£o assÃ­ncrona. Ou seja, vocÃª roda o teste, o Jest analisa as funÃ§Ãµes sÃ­ncronas, nÃ£o espera as assÃ­ncronas terminarem e, dado o final do teste, gera um resultado positivo antes de um eventual problema numa funÃ§Ã£o assÃ­ncrona acusar um erro.
O exemplo abaixo gera um falso-positivo:
Copiar
test('NÃ£o deveria passar!', () => {
  setTimeout(() => {
    expect(10).toBe(5);
    console.log('Deveria falhar!');
  }, 500);
});
Copie o cÃ³digo acima em um arquivo .test.js e execute o comando npm test na sua mÃ¡quina para ver! Como o setTimeout Ã© uma funÃ§Ã£o assÃ­ncrona, o teste retorna um resultado falso-positivo quando executado dessa forma â€” note, inclusive, que a frase "Deveria falhar!" sequer aparece no console.
Para que o Jest espere a funÃ§Ã£o assÃ­ncrona ser finalizada, Ã© necessÃ¡rio utilizar uma callback prÃ³pria da biblioteca, chamada done , que precisa ser chamada apÃ³s os testes assÃ­ncronos.
Vamos reescrever o teste chamando a callback done apÃ³s a asserÃ§Ã£o para indicar que o teste acabou: O termo asserÃ§Ã£o Ã© a verificaÃ§Ã£o realizada pelo Jest para saber se um valor atende alguma condiÃ§Ã£o
Copiar
test('NÃ£o deveria passar!', (done) => {
  setTimeout(() => {
    expect(10).toBe(5);
    console.log('Deveria falhar!');
    done();
  }, 500);
});
Apesar do cÃ³digo acima parecer correto, irÃ¡ falhar com uma mensagem de timeout. O motivo Ã© que quando uma asserÃ§Ã£o (verificaÃ§Ã£o) falha, a exceÃ§Ã£o Ã© lanÃ§ada, ou seja, algo inesperado aconteceu. Dessa forma, o fluxo Ã© interrompido antes que a instruÃ§Ã£o done() seja executada. Para resolver este problema podemos colocar um bloco try/catch em volta da nossa asserÃ§Ã£o. Enquanto o try tenta executar a funÃ§Ã£o no seu escopo com sucesso, o catch "captura" o erro, chamando a callback done :
Copiar
test('NÃ£o deveria passar!', (done) => {
  setTimeout(() => {
    try {
      expect(10).toBe(5);
      console.log('Deveria falhar!');
      done();
    } catch (error) {
      done();
    }
  }, 500);
});
Estamos quase lÃ¡... O cÃ³digo acima irÃ¡ gerar um falso-positivo. O motivo Ã© que nÃ£o estamos passando nenhuma aÃ§Ã£o a ser realizada quando o erro acontece e "encerramos" nosso teste com o done() sem lanÃ§ar nenhum erro, dessa forma o teste Ã© interpretado como "correto". Para resolver, podemos passar o parÃ¢metro de erro para o catch . Dessa forma, caso nosso try nÃ£o consiga executar o cÃ³digo dentro dele, cairÃ¡ no catch , que vai pegar esse erro e vai encerrar nosso teste lanÃ§ando um erro.
Copiar
test('NÃ£o deveria passar!', (done) => {
  setTimeout(() => {
    try {
      expect(10).toBe(5);
      console.log('Deveria falhar!');
      done();
    } catch (error) {
      done(error); // Alteramos esta linha
    }
  }, 500);
});
Agora sim, nosso teste falhou! Isso significa que vocÃª conseguiu testar com sucesso a callback.
Vamos a mais um exemplo para fixaÃ§Ã£o, desta vez vocÃª irÃ¡ implementar uma funÃ§Ã£o que espera um tempo e retorna a soma de dois nÃºmeros:
Copiar
const asyncSum = (a, b, callback) => {
  setTimeout(() => {
    const result = a + b;
    callback(result);
  }, 500);
};

test('Testando asyncSum, soma 5 mais 10', (done) => {
  asyncSum(5, 10, (result) => {
    try {
      expect(result).toBe(15);
      done();
    } catch (error) {
      done(error);
    }
  });
});
Quando estiver realizando testes, Ã© muito importante verificar se os resultados exibidos nÃ£o sÃ£o falso-positivos. No exemplo acima, em que o teste estÃ¡ passando, experimente mudar a implementaÃ§Ã£o da funÃ§Ã£o asyncSum para que retorne valores incorretos e verifique se o teste irÃ¡ falhar. Por exemplo, se mudarmos os resultado para ser a + b + 1 o teste falha dizendo que esperava 15 , mas recebeu 16 .
NÃ£o se preocupe, vamos treinar bastante! Agora, vamos para o prÃ³ximo tÃ³pico \o/
Acredite, vai ser muito Ãºtil pois vocÃª vai conseguir economizar tempo e cÃ³digo ;)

Setup e Teardown
Quando vocÃª estÃ¡ lidando com um ambiente de testes dentro do jest, Ã© importante saber que existem 3 ciclos, sendo possÃ­vel utilizar cada um deles para ajudar a configurar e realizar seus testes.
AtÃ© esse momento, vocÃª viu como realizar os testes utilizando o Jest, que Ã© apenas um dos ciclos possÃ­veis. Vamos entender, a seguir, quais sÃ£o os outros dois.
Setup - Ã© o primeiro ciclo. Ele ocorre antes dos testes serem executados. Ã‰ uma fase inicial que vocÃª pode definir algumas configuraÃ§Ãµes.
Testes - Ã© considerado o segundo ciclo, ou seja, o momento em que ocorrem os testes. O ciclo em que foi trabalhado nos blocos anteriores.
Teardown - Ã© o terceiro ciclo. Uma fase que ocorre apÃ³s os testes serem executados.
Maravilha! Agora que vocÃª sabe conceitualmente que existem esses ciclos dentro do ambiente de testes, vocÃª irÃ¡ entender primeiro porque precisamos deles.
Para entender isso, dÃª uma olhada nos cÃ³digos a seguir:
Copiar
// cicles.test.js

let cities = [];

const addCity = (city) => {
  cities.push(city);
};

const removeCity = (city) => {
  cities = cities.filter((eachCity) => eachCity !== city);
};
Aqui temos a declaraÃ§Ã£o de uma variÃ¡vel cities , que Ã© uma lista de cidades;
HÃ¡ duas funÃ§Ãµes, addCity que adiciona cidades ao array e removeCity que... Pasmem! Remove cidades desse array.
Agora vocÃª vai realizar dois testes, para saber se essas funÃ§Ãµes funcionam exatamente como deseja.
Copiar
// cicles.test.js

// let cities = [];

// const addCity = (city) => {
//  cities.push(city);
// };

// const removeCity = (city) => {
//  cities = cities.filter((eachCity) => eachCity !== city);
// };

test('Testa a funÃ§Ã£o addCity', () => {
  expect.assertions(4);
  addCity('Campinas');
  addCity('Goiania');
  addCity('Recife');
  expect(cities).toHaveLength(3);
  expect(cities).toContain('Campinas');
  expect(cities).toContain('Goiania');
  expect(cities).toContain('Recife');
});

test('Testa a funÃ§Ã£o removeCity', () => {
  expect.assertions(4);
  removeCity('Campinas');
  expect(cities).toHaveLength(2);
  expect(cities).not.toContain('Campinas');
  expect(cities).toContain('Goiania');
  expect(cities).toContain('Recife');
});

Como vocÃª observou, os testes tiveram sucesso, significando que as funÃ§Ãµes estÃ£o funcionando.
Mas... e se vocÃª criar outras funÃ§Ãµes, que tambÃ©m manipulam os dados das cidades?
Isso farÃ¡ com que vocÃª tenha que escrever novos testes.
Portanto, vocÃª teria que lembrar de como o array de cidades ficou apÃ³s o Ãºltimo teste, para poder continuar do ponto onde parou, certo?
Imagine quanto tempo vocÃª perderia se tivesse uma aplicaÃ§Ã£o com dezenas de funÃ§Ãµes?
Para lidar com essa questÃ£o Ã© que existem os ciclos de setup e teardown .
Maravilha! Agora que compreendeu porque eles existem, vocÃª vai entender como eles sÃ£o utilizados.
Copiar
// cicles.test.js

// let cities = [];

// const addCity = (city) => {
// cities.push(city);
// };

// const removeCity = (city) => {
// cities = cities.filter((eachCity) => eachCity !== city);
// };

beforeEach(() => {
  cities = ['Pindamonhangaba'];
});

afterEach(() => {
  cities = [];
});

test('Testa a funÃ§Ã£o addCity utilizando o beforeEach', () => {
  expect.assertions(3);
  addCity('Piraporinha');
  expect(cities).toHaveLength(2);
  expect(cities).toContain('Pindamonhangaba');
  expect(cities).toContain('Piraporinha');
});

test('Testa a funÃ§Ã£o removeCity utilizando o beforeEach', () => {
  expect.assertions(2);
  removeCity('Pindamonhangaba');
  expect(cities).not.toContain('Pindamonhangaba');
  expect(cities).toHaveLength(0);
});
No cÃ³digo acima, vocÃª declarou uma funÃ§Ã£o beforeEach , que roda antes de cada um dos testes, ou seja, nÃ£o importa quantos testes sejam criados, a funÃ§Ã£o rodarÃ¡ antes de cada um deles, para definir as suas configuraÃ§Ãµes. Como visto antes, este Ã© o ciclo anterior aos testes chamado de setup .
Nesta fase, Ã© configurado o array para ter sempre o valor ['Pindamonhangaba'] , portanto, em todos os testes realizados, o valor do array serÃ¡ sempre o mesmo.
TambÃ©m declaramos uma funÃ§Ã£o afterEach , que roda apÃ³s cada um dos testes e faz a limpeza dos dados do nosso array depois de cada execuÃ§Ã£o. AlÃ©m disso, como o prÃ³prio nome indica, ela Ã© executada apÃ³s cada teste no terceiro ciclo dos testes, que Ã© a fase de teardown .
Geralmente utilizamos esta fase para limpar os valores que foram manipulados durante os testes.
Agora, se vocÃª tem um bloco de describe agrupando os testes, e o beforeEach ou afterEach estiverem dentro desse describe , ele rodarÃ¡ apenas dentro dos testes que estÃ£o nesse describe .
Ou seja, se criarmos um segundo describe , aquele beforeEach e afterEach que estÃ£o no primeiro describe nÃ£o serÃ£o rodados antes e/ou depois dos testes do segundo.
Para visualizar melhor, veja outro exemplo dentro do mesmo contexto.
Copiar
// cicles.test.js

// let cities = [];

// const addCity = (city) => {
// cities.push(city);
// };

// const removeCity = (city) => {
// cities = cities.filter((eachCity) => eachCity !== city);
// };

describe('Agrupa o primeiro bloco de testes', () => {
  beforeEach(() => {
    cities = ['Pindamonhangaba'];
  });
  
  afterEach(() => {
    cities = [];
  });
  
  test('Testa a funÃ§Ã£o addCity dentro do primeiro bloco de testes', () => {
    expect.assertions(3);
    addCity('Piraporinha');
    expect(cities).toHaveLength(2);
    expect(cities).toContain('Pindamonhangaba');
    expect(cities).toContain('Piraporinha');
  });
  
  test('Testa a funÃ§Ã£o removeCity dentro do primeiro bloco de testes', () => {
    expect.assertions(2);
    removeCity('Pindamonhangaba');
    expect(cities).not.toContain('Pindamonhangaba');
    expect(cities).toHaveLength(0);
  });
});

describe('Agrupa o segundo bloco de testes', () => {
  beforeEach(() => {
    cities = ['Tangamandapio'];
  });
  
  afterEach(() => {
    cities = [];
  });
  
  test('Testa a funÃ§Ã£o addCity dentro do segundo bloco de testes', () => {
    expect.assertions(3);
    expect(cities).toHaveLength(1);
    expect(cities).not.toContain('Pindamonhangaba');
    expect(cities).toContain('Tangamandapio');
  });
  
  test('Testa a funÃ§Ã£o removeCity dentro do segundo bloco de testes', () => {
    expect.assertions(2);
    removeCity('Tangamandapio');
    expect(cities).not.toContain('Pindamonhangaba');
    expect(cities).toHaveLength(0);
  });
});
Ao rodar esses testes, terÃ¡ o seguinte resultado:

Dessa maneira, vocÃª pode organizar uma configuraÃ§Ã£o para cada bloco de testes dentro de um describe .
Uma questÃ£o importante Ã© que para facilitar o entendimento, nÃ³s utilizamos funÃ§Ãµes sÃ­ncronas para entender como utilizar o setup e o teardown , porÃ©m elas geralmente sÃ£o utilizadas em funÃ§Ãµes assÃ­ncronas.
Ufa, bastante coisa nÃ£o Ã© mesmo? Aproveite para fazer uma pausa, tomar um cafÃ©, se alongar e volte para fixar seus conhecimentos!
done

